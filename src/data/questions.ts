import type { Question } from '../types/question.types.js';

export const questions: Question[] = [
  // React Core
  {
    id: 'react-1',
    category: 'React Core',
    question: 'Что такое Virtual DOM в React?',
    answers: [
      'Легковесная копия реального DOM в виде JS-объекта, используемая для оптимизации обновлений интерфейса',
      'Специальный браузерный API для работы с DOM',
      'Библиотека для работы с DOM',
      'Альтернатива реальному DOM, которая полностью заменяет его',
    ],
    correctAnswerIndex: 0,
    explanation: 'Virtual DOM - это легковесная копия реального DOM в виде JS-объекта. React использует его для оптимизации: сравнивает изменения между VDOM и актуальным DOM (diffing), обновляет только различающиеся части (reconciliation), избегая дорогих операций прямого изменения DOM.',
  },
  {
    id: 'react-2',
    category: 'React Core',
    question: 'Что такое JSX?',
    answers: [
      'JavaScript XML - расширение синтаксиса JavaScript, позволяющее использовать HTML-подобный синтаксис для описания структуры интерфейса',
      'Специальный язык программирования для React',
      'Библиотека для работы с XML',
      'Альтернативное название для TypeScript',
    ],
    correctAnswerIndex: 0,
    explanation: 'JSX (JavaScript XML) - это расширение синтаксиса JavaScript. В результате компиляции JSX и вызова React.createElement() возникают простые объекты - React-элементы, которые описывают, что нужно отрисовать на экране.',
  },
  {
    id: 'react-3',
    category: 'React Core',
    question: 'В чем разница между props и state?',
    answers: [
      'Props менять нельзя, State изменяем. При изменении state React отрисовывает новый интерфейс',
      'Props и State - это одно и то же',
      'Props можно изменять, State нельзя',
      'Props используются только в классовых компонентах, State - в функциональных',
    ],
    correctAnswerIndex: 0,
    explanation: 'Props (properties) - это данные, передаваемые от родительского компонента к дочернему, их нельзя изменять. State - это внутреннее состояние компонента, которое можно изменять через setState или useState. При изменении state React перерисовывает компонент.',
  },
  {
    id: 'react-4',
    category: 'React Hooks',
    question: 'Что делает хук useState?',
    answers: [
      'Позволяет работать со стейтом в функциональном компоненте, давая компоненту локальное состояние',
      'Позволяет выполнять побочные эффекты в функциональном компоненте',
      'Позволяет использовать контекст в функциональном компоненте',
      'Позволяет работать со стейтом с помощью редьюсера',
    ],
    correctAnswerIndex: 0,
    explanation: 'useState - это хук, который позволяет функциональным компонентам иметь локальное состояние. Он возвращает массив из двух элементов: текущее значение состояния и функцию для его обновления.',
  },
  {
    id: 'react-5',
    category: 'React Hooks',
    question: 'В чем разница между useEffect и useLayoutEffect?',
    answers: [
      'useEffect выполняется после отрисовки (асинхронно), useLayoutEffect - синхронно после обновления DOM, но до отрисовки',
      'useEffect и useLayoutEffect работают одинаково',
      'useEffect используется только в классовых компонентах',
      'useLayoutEffect выполняется асинхронно, useEffect - синхронно',
    ],
    correctAnswerIndex: 0,
    explanation: 'useEffect выполняется после отрисовки компонента (асинхронно), не блокируя браузер. useLayoutEffect выполняется синхронно после обновления DOM, но до того, как браузер отрисует изменения. Используйте useLayoutEffect только когда нужна моментальная отрисовка для изменения стилей или размеров.',
  },
  {
    id: 'react-6',
    category: 'React Hooks',
    question: 'Что делает хук useMemo?',
    answers: [
      'Возвращает кэшированное значение, которое не изменяется, если значения зависимостей не изменились',
      'Возвращает кэшированную функцию',
      'Позволяет работать со стейтом',
      'Позволяет выполнять побочные эффекты',
    ],
    correctAnswerIndex: 0,
    explanation: 'useMemo запоминает результат вычисления функции и повторно использует его, если зависимости не изменились. Это помогает улучшить производительность, избегая дорогих вычислений при каждом рендере.',
  },
  {
    id: 'react-7',
    category: 'React Hooks',
    question: 'Что делает хук useCallback?',
    answers: [
      'Возвращает кэшированную функцию, которая не изменяется, если значения зависимостей не изменились',
      'Возвращает кэшированное значение',
      'Позволяет работать со стейтом',
      'Позволяет выполнять побочные эффекты',
    ],
    correctAnswerIndex: 0,
    explanation: 'useCallback запоминает функцию и повторно использует ее, если зависимости не изменились. Это помогает улучшить производительность и уменьшить количество создаваемых функций, особенно полезно в связке с useEffect или React.memo.',
  },
  {
    id: 'react-8',
    category: 'React Hooks',
    question: 'В чем разница между React.memo, useMemo и useCallback?',
    answers: [
      'React.memo оптимизирует компоненты, useMemo - значения, useCallback - функции',
      'Все три работают одинаково',
      'React.memo используется только в классовых компонентах',
      'useMemo и useCallback - это одно и то же',
    ],
    correctAnswerIndex: 0,
    explanation: 'React.memo оборачивает компонент и предотвращает его перерендер, если props не изменились. useMemo запоминает вычисленное значение. useCallback запоминает функцию. Все три используются для оптимизации производительности.',
  },
  {
    id: 'react-9',
    category: 'React Core',
    question: 'Что такое React Fiber?',
    answers: [
      'Новая реализация алгоритма ядра React для улучшения производительности, позволяющая использовать планирование и инкрементный рендеринг',
      'Библиотека для работы с сетью',
      'Специальный синтаксис для React',
      'Альтернативное название для Virtual DOM',
    ],
    correctAnswerIndex: 0,
    explanation: 'React Fiber - это новая реализация алгоритма ядра React, которая позволяет использовать планирование и инкрементный рендеринг. Она обеспечивает более быстрый рендеринг, улучшенную обработку ошибок и поддержку инкрементного рендеринга.',
  },
  {
    id: 'react-10',
    category: 'React Core',
    question: 'Что такое Reconciliation (примирение) в React?',
    answers: [
      'Процесс сравнения виртуального DOM с реальным DOM и внесения необходимых изменений',
      'Процесс создания компонентов',
      'Процесс удаления компонентов',
      'Процесс обновления состояния',
    ],
    correctAnswerIndex: 0,
    explanation: 'Reconciliation (примирение) - это процесс, когда React сравнивает виртуальный DOM с реальным DOM и вносит необходимые изменения. Это позволяет React эффективно обновлять только те части интерфейса, которые действительно изменились.',
  },
  {
    id: 'react-11',
    category: 'React Core',
    question: 'Что такое Batching в React?',
    answers: [
      'Процесс накопления изменений состояния и применения их за один рендер для оптимизации',
      'Процесс создания компонентов',
      'Процесс удаления компонентов',
      'Процесс загрузки данных',
    ],
    correctAnswerIndex: 0,
    explanation: 'Batching - это процесс, когда React накапливает несколько изменений состояния и применяет их за один рендер, вместо того чтобы перерисовывать компонент после каждого изменения. Это улучшает производительность.',
  },
  {
    id: 'react-12',
    category: 'React Core',
    question: 'В чем разница между контролируемым и неконтролируемым компонентом?',
    answers: [
      'Контролируемый компонент имеет state, с которым мы взаимодействуем. Неконтролируемый имеет state, с которым не взаимодействуем (например, через ref)',
      'Контролируемый компонент нельзя изменять, неконтролируемый можно',
      'Контролируемый компонент используется только в классовых компонентах',
      'Неконтролируемый компонент используется только в функциональных компонентах',
    ],
    correctAnswerIndex: 0,
    explanation: 'Контролируемый компонент - это компонент, состояние которого контролируется React через props и state. Неконтролируемый компонент хранит свое состояние в DOM (например, через ref) и React не контролирует его напрямую.',
  },
  {
    id: 'react-13',
    category: 'React Hooks',
    question: 'Что делает хук useRef?',
    answers: [
      'Возвращает ссылку, которая не изменяется между рендерами и может быть использована для хранения данных, которые не должны влиять на рендеринг',
      'Позволяет работать со стейтом',
      'Позволяет выполнять побочные эффекты',
      'Позволяет использовать контекст',
    ],
    correctAnswerIndex: 0,
    explanation: 'useRef возвращает мутабельный объект, свойство current которого инициализируется переданным аргументом. Объект ref сохраняется на протяжении всего времени жизни компонента и не вызывает ререндер при изменении.',
  },
  {
    id: 'react-14',
    category: 'React Hooks',
    question: 'Что делает хук useContext?',
    answers: [
      'Позволяет использовать контекст в функциональном компоненте',
      'Позволяет работать со стейтом',
      'Позволяет выполнять побочные эффекты',
      'Позволяет использовать ref',
    ],
    correctAnswerIndex: 0,
    explanation: 'useContext позволяет функциональным компонентам подписаться на контекст React. Он принимает объект контекста и возвращает текущее значение контекста для этого контекста.',
  },
  {
    id: 'react-15',
    category: 'React Hooks',
    question: 'Что делает хук useReducer?',
    answers: [
      'Позволяет работать со стейтом с помощью редьюсера в функциональном компоненте',
      'Позволяет выполнять побочные эффекты',
      'Позволяет использовать контекст',
      'Позволяет использовать ref',
    ],
    correctAnswerIndex: 0,
    explanation: 'useReducer - это альтернатива useState. Он принимает редьюсер и начальное состояние, возвращает текущее состояние и метод dispatch для обновления состояния. Полезен для сложной логики состояния.',
  },
  {
    id: 'react-16',
    category: 'React Core',
    question: 'Что такое Concurrent Mode в React 18?',
    answers: [
      'Новый режим работы React, который позволяет более эффективно использовать ресурсы и обеспечивает более плавный интерфейс через параллельный рендеринг',
      'Режим работы только для серверных компонентов',
      'Режим работы только для классовых компонентов',
      'Альтернативное название для Virtual DOM',
    ],
    correctAnswerIndex: 0,
    explanation: 'Concurrent Mode - это новый режим работы React 18, который делает рендеринг прерываемым. React может приостановить рендеринг для более приоритетных задач, что обеспечивает более плавный пользовательский интерфейс.',
  },
  {
    id: 'react-17',
    category: 'React Hooks',
    question: 'Что делает хук useTransition?',
    answers: [
      'Позволяет делать отложенный рендер, помечая обновления как переходы',
      'Позволяет работать со стейтом',
      'Позволяет выполнять побочные эффекты',
      'Позволяет использовать контекст',
    ],
    correctAnswerIndex: 0,
    explanation: 'useTransition позволяет обновлять состояние без блокировки UI. Он возвращает массив с isPending (индикатор перехода) и startTransition (функция для обновления состояния). Полезен для обновлений, которые не критичны для немедленного отображения.',
  },
  {
    id: 'react-18',
    category: 'React Hooks',
    question: 'Что делает хук useDeferredValue?',
    answers: [
      'Хук, похожий на debounce, но с отложенной перерисовкой компонента',
      'Позволяет работать со стейтом',
      'Позволяет выполнять побочные эффекты',
      'Позволяет использовать контекст',
    ],
    correctAnswerIndex: 0,
    explanation: 'useDeferredValue принимает значение и возвращает новую копию этого значения, которая будет отложена для обновления. Это полезно для отложенных обновлений, которые не критичны для немедленного отображения.',
  },
  {
    id: 'react-19',
    category: 'React Core',
    question: 'Что такое Error Boundary в React?',
    answers: [
      'Компонент, который перехватывает ошибки JavaScript в любом месте дерева дочерних компонентов',
      'Специальный хук для обработки ошибок',
      'Метод для обработки ошибок в useEffect',
      'Альтернативное название для try-catch',
    ],
    correctAnswerIndex: 0,
    explanation: 'Error Boundary - это компонент React, который перехватывает ошибки JavaScript в любом месте дерева дочерних компонентов, логирует эти ошибки и отображает запасной UI вместо компонента, который упал с ошибкой.',
  },
  {
    id: 'react-20',
    category: 'React Core',
    question: 'Что такое React.memo?',
    answers: [
      'Функция для оптимизации производительности функциональных компонентов, предотвращающая перерендер при неизменных props',
      'Хук для работы со стейтом',
      'Хук для выполнения побочных эффектов',
      'Метод для создания компонентов',
    ],
    correctAnswerIndex: 0,
    explanation: 'React.memo - это функция высшего порядка, которая оборачивает компонент и предотвращает его перерендер, если props не изменились. По умолчанию используется поверхностное сравнение props.',
  },
  // JavaScript
  {
    id: 'js-1',
    category: 'JavaScript',
    question: 'Что такое замыкание (closure) в JavaScript?',
    answers: [
      'Способность функции запоминать и иметь доступ к переменным из внешней области видимости',
      'Способ создания объектов',
      'Способ работы с массивами',
      'Альтернативное название для функции',
    ],
    correctAnswerIndex: 0,
    explanation: 'Замыкание - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Функция имеет доступ к переменным из внешней области видимости даже после того, как внешняя функция завершила выполнение.',
  },
  {
    id: 'js-2',
    category: 'JavaScript',
    question: 'В чем разница между let, const и var?',
    answers: [
      'var имеет функциональную область видимости и поднимается, let и const имеют блочную область видимости, const нельзя переназначить',
      'Все три работают одинаково',
      'var используется только в старых версиях JavaScript',
      'let и const - это одно и то же',
    ],
    correctAnswerIndex: 0,
    explanation: 'var имеет функциональную область видимости и поднимается (hoisting). let и const имеют блочную область видимости. const нельзя переназначить после инициализации, но объект const можно мутировать.',
  },
  {
    id: 'js-3',
    category: 'JavaScript',
    question: 'Что такое Promise в JavaScript?',
    answers: [
      'Объект, представляющий результат асинхронной операции, которая может завершиться успешно или с ошибкой',
      'Способ создания функций',
      'Способ работы с массивами',
      'Альтернативное название для callback',
    ],
    correctAnswerIndex: 0,
    explanation: 'Promise - это объект, представляющий результат асинхронной операции. Он может находиться в одном из состояний: pending (ожидание), fulfilled (выполнено) или rejected (отклонено).',
  },
  {
    id: 'js-4',
    category: 'JavaScript',
    question: 'В чем разница между async/await и Promise?',
    answers: [
      'async/await - это синтаксический сахар над Promise, делающий асинхронный код более читаемым',
      'async/await и Promise - это разные языки',
      'async/await работает только в браузере',
      'Promise работает только на сервере',
    ],
    correctAnswerIndex: 0,
    explanation: 'async/await - это синтаксический сахар над Promise, который позволяет писать асинхронный код в синхронном стиле. Функция async всегда возвращает Promise, а await приостанавливает выполнение до разрешения Promise.',
  },
  {
    id: 'js-5',
    category: 'JavaScript',
    question: 'Что такое Event Loop в JavaScript?',
    answers: [
      'Механизм, который управляет выполнением кода, обработкой событий и выполнением подзадач',
      'Способ создания циклов',
      'Способ работы с массивами',
      'Альтернативное название для setTimeout',
    ],
    correctAnswerIndex: 0,
    explanation: 'Event Loop - это механизм, который позволяет JavaScript выполнять неблокирующие операции. Он постоянно проверяет очередь задач и выполняет их, когда стек вызовов пуст.',
  },
  // TypeScript
  {
    id: 'ts-1',
    category: 'TypeScript',
    question: 'В чем основное преимущество TypeScript перед JavaScript?',
    answers: [
      'Статическая типизация, которая помогает выявлять ошибки на этапе разработки',
      'TypeScript быстрее JavaScript',
      'TypeScript работает только в браузере',
      'TypeScript не требует компиляции',
    ],
    correctAnswerIndex: 0,
    explanation: 'TypeScript добавляет статическую типизацию к JavaScript, что позволяет выявлять ошибки на этапе разработки, улучшает автодополнение в IDE и делает код более поддерживаемым.',
  },
  {
    id: 'ts-2',
    category: 'TypeScript',
    question: 'В чем разница между interface и type в TypeScript?',
    answers: [
      'interface можно расширять и объединять, type более гибкий и может представлять примитивы, объединения и пересечения',
      'interface и type - это одно и то же',
      'interface используется только для классов',
      'type используется только для функций',
    ],
    correctAnswerIndex: 0,
    explanation: 'interface можно расширять (extends) и объединять (merge declaration). type более гибкий и может представлять примитивы, объединения, пересечения и другие сложные типы. В большинстве случаев для объектов предпочтительнее interface.',
  },
  // Performance
  {
    id: 'perf-1',
    category: 'Performance',
    question: 'Что такое Code Splitting в React?',
    answers: [
      'Техника разделения кода на более мелкие части, которые загружаются по требованию',
      'Способ создания компонентов',
      'Способ работы с состоянием',
      'Альтернативное название для lazy loading',
    ],
    correctAnswerIndex: 0,
    explanation: 'Code Splitting позволяет разделить код приложения на более мелкие части (chunks), которые загружаются по требованию. Это уменьшает начальный размер бандла и улучшает время загрузки приложения.',
  },
  {
    id: 'perf-2',
    category: 'Performance',
    question: 'Что такое Lazy Loading в React?',
    answers: [
      'Техника отложенной загрузки компонентов с помощью React.lazy и Suspense',
      'Способ создания компонентов',
      'Способ работы с состоянием',
      'Альтернативное название для Code Splitting',
    ],
    correctAnswerIndex: 0,
    explanation: 'Lazy Loading позволяет загружать компоненты только когда они действительно нужны. React.lazy позволяет загружать компонент динамически, а Suspense показывает fallback UI во время загрузки.',
  },
  // Next.js
  {
    id: 'next-1',
    category: 'Next.js',
    question: 'В чем разница между SSR и SSG в Next.js?',
    answers: [
      'SSR генерирует HTML на сервере при каждом запросе, SSG генерирует HTML на этапе сборки',
      'SSR и SSG - это одно и то же',
      'SSR работает только в браузере',
      'SSG работает только на сервере',
    ],
    correctAnswerIndex: 0,
    explanation: 'SSR (Server-Side Rendering) генерирует HTML на сервере при каждом запросе, что обеспечивает актуальные данные, но увеличивает время ответа. SSG (Static Site Generation) генерирует HTML на этапе сборки, что обеспечивает быструю загрузку, но данные могут быть устаревшими.',
  },
  {
    id: 'next-2',
    category: 'Next.js',
    question: 'Что такое ISR (Incremental Static Regeneration) в Next.js?',
    answers: [
      'Техника, позволяющая обновлять статические страницы после сборки без полной пересборки',
      'Способ создания компонентов',
      'Способ работы с состоянием',
      'Альтернативное название для SSR',
    ],
    correctAnswerIndex: 0,
    explanation: 'ISR позволяет обновлять статические страницы после сборки. Вы можете указать интервал времени (revalidate), после которого страница будет перегенерирована в фоновом режиме при следующем запросе.',
  },
  {
    id: 'next-3',
    category: 'Next.js',
    question: 'Что такое React Server Components в Next.js 13+?',
    answers: [
      'Компоненты, которые рендерятся на сервере и не отправляют JavaScript на клиент',
      'Компоненты, которые работают только в браузере',
      'Альтернативное название для SSR',
      'Компоненты, которые работают только в классовых компонентах',
    ],
    correctAnswerIndex: 0,
    explanation: 'React Server Components рендерятся на сервере и не отправляют JavaScript на клиент, что уменьшает размер бандла и улучшает производительность. Они могут напрямую обращаться к серверным ресурсам.',
  },
  // State Management
  {
    id: 'state-1',
    category: 'State Management',
    question: 'В чем разница между Redux и Context API?',
    answers: [
      'Redux предоставляет централизованное хранилище с предсказуемыми обновлениями через actions/reducers, Context API - простой способ передачи данных через дерево компонентов',
      'Redux и Context API - это одно и то же',
      'Redux работает только в браузере',
      'Context API работает только на сервере',
    ],
    correctAnswerIndex: 0,
    explanation: 'Redux - это библиотека для управления состоянием с централизованным хранилищем, actions и reducers. Context API - встроенный в React механизм для передачи данных через дерево компонентов без prop drilling. Redux лучше для сложного состояния, Context API - для простых случаев.',
  },
  {
    id: 'state-2',
    category: 'State Management',
    question: 'Что такое Redux Toolkit (RTK)?',
    answers: [
      'Официальный набор инструментов для эффективной разработки Redux, упрощающий написание Redux логики',
      'Альтернатива Redux',
      'Способ создания компонентов',
      'Альтернативное название для Context API',
    ],
    correctAnswerIndex: 0,
    explanation: 'Redux Toolkit - это официальный набор инструментов для Redux, который упрощает написание Redux логики. Он включает createSlice, createAsyncThunk, configureStore и другие утилиты, которые уменьшают boilerplate код.',
  },
  // Testing
  {
    id: 'test-1',
    category: 'Testing',
    question: 'Что такое unit тесты в контексте React?',
    answers: [
      'Тесты, которые проверяют отдельные компоненты или функции в изоляции',
      'Тесты, которые проверяют все приложение целиком',
      'Тесты, которые проверяют только UI',
      'Тесты, которые проверяют только серверную часть',
    ],
    correctAnswerIndex: 0,
    explanation: 'Unit тесты проверяют отдельные компоненты или функции в изоляции. В React это обычно означает тестирование компонентов с помощью React Testing Library или Enzyme, проверяя их поведение и рендеринг.',
  },
  {
    id: 'test-2',
    category: 'Testing',
    question: 'В чем разница между React Testing Library и Enzyme?',
    answers: [
      'React Testing Library фокусируется на тестировании поведения с точки зрения пользователя, Enzyme позволяет тестировать внутреннюю реализацию',
      'React Testing Library и Enzyme - это одно и то же',
      'React Testing Library работает только в браузере',
      'Enzyme работает только на сервере',
    ],
    correctAnswerIndex: 0,
    explanation: 'React Testing Library поощряет тестирование компонентов так, как пользователь взаимодействует с ними, фокусируясь на поведении. Enzyme позволяет тестировать внутреннюю реализацию компонентов, что может быть менее устойчивым к рефакторингу.',
  },
  // Performance
  {
    id: 'perf-3',
    category: 'Performance',
    question: 'Что такое React.memo и когда его использовать?',
    answers: [
      'Функция для мемоизации компонентов, предотвращающая перерендер при неизменных props. Используйте для дорогих компонентов',
      'Хук для работы со стейтом',
      'Способ создания компонентов',
      'Альтернативное название для useMemo',
    ],
    correctAnswerIndex: 0,
    explanation: 'React.memo оборачивает компонент и предотвращает его перерендер, если props не изменились. Используйте его для компонентов, которые рендерятся часто с теми же props, особенно если рендеринг дорогой.',
  },
  {
    id: 'perf-4',
    category: 'Performance',
    question: 'Что такое виртуализация списков и когда ее использовать?',
    answers: [
      'Техника рендеринга только видимых элементов списка для улучшения производительности при больших списках',
      'Способ создания списков',
      'Способ работы с состоянием',
      'Альтернативное название для lazy loading',
    ],
    correctAnswerIndex: 0,
    explanation: 'Виртуализация списков рендерит только видимые элементы, что значительно улучшает производительность при работе с большими списками (тысячи элементов). Популярные библиотеки: react-window, react-virtualized.',
  },
  // Architecture
  {
    id: 'arch-1',
    category: 'Architecture',
    question: 'Что такое Component Composition в React?',
    answers: [
      'Паттерн построения сложных компонентов из более простых, переиспользуемых компонентов',
      'Способ создания компонентов',
      'Способ работы с состоянием',
      'Альтернативное название для наследования',
    ],
    correctAnswerIndex: 0,
    explanation: 'Component Composition - это паттерн, при котором сложные компоненты строятся из более простых, переиспользуемых компонентов. Это предпочтительнее наследования и способствует созданию гибких и поддерживаемых интерфейсов.',
  },
  {
    id: 'arch-2',
    category: 'Architecture',
    question: 'Что такое Render Props паттерн?',
    answers: [
      'Паттерн, при котором компонент принимает функцию как prop, которая возвращает React элемент',
      'Способ создания компонентов',
      'Способ работы с состоянием',
      'Альтернативное название для HOC',
    ],
    correctAnswerIndex: 0,
    explanation: 'Render Props - это паттерн, при котором компонент принимает функцию (обычно называемую render prop) как prop, которая возвращает React элемент. Это позволяет компонентам делиться логикой и состоянием.',
  },
  // Advanced React
  {
    id: 'react-21',
    category: 'React Core',
    question: 'Что такое Portals в React?',
    answers: [
      'Способ рендеринга дочерних элементов в узел DOM, который находится вне иерархии родительского компонента',
      'Способ создания компонентов',
      'Способ работы с состоянием',
      'Альтернативное название для Context',
    ],
    correctAnswerIndex: 0,
    explanation: 'Portals позволяют рендерить дочерние элементы в узел DOM, который находится вне иерархии родительского компонента. Полезно для модальных окон, тултипов и других элементов, которые должны быть поверх всего контента.',
  },
  {
    id: 'react-22',
    category: 'React Hooks',
    question: 'Что делает хук useId?',
    answers: [
      'Возвращает уникальный ID, который стабилен между серверным и клиентским рендерингом',
      'Позволяет работать со стейтом',
      'Позволяет выполнять побочные эффекты',
      'Позволяет использовать контекст',
    ],
    correctAnswerIndex: 0,
    explanation: 'useId генерирует уникальный ID, который стабилен между серверным и клиентским рендерингом. Полезен для генерации уникальных ID для доступности (accessibility) и других случаев, когда нужен стабильный ID.',
  },
  {
    id: 'react-23',
    category: 'React Core',
    question: 'Что такое ключ (key) в React и зачем он нужен?',
    answers: [
      'Специальный атрибут, который помогает React идентифицировать, какие элементы изменились, были добавлены или удалены',
      'Способ создания компонентов',
      'Способ работы с состоянием',
      'Альтернативное название для id',
    ],
    correctAnswerIndex: 0,
    explanation: 'Key помогает React идентифицировать элементы в списке. Без key React может неправильно обновлять компоненты при изменении порядка элементов. Key должны быть уникальными среди siblings.',
  },
  {
    id: 'react-24',
    category: 'React Hooks',
    question: 'Что делает хук useImperativeHandle?',
    answers: [
      'Позволяет настроить значение ref, которое передается родительскому компоненту при использовании forwardRef',
      'Позволяет работать со стейтом',
      'Позволяет выполнять побочные эффекты',
      'Позволяет использовать контекст',
    ],
    correctAnswerIndex: 0,
    explanation: 'useImperativeHandle используется вместе с forwardRef для настройки значения ref, которое передается родительскому компоненту. Это позволяет родителю вызывать определенные методы дочернего компонента.',
  },
  // JavaScript Advanced
  {
    id: 'js-6',
    category: 'JavaScript',
    question: 'Что такое деструктуризация (destructuring) в JavaScript?',
    answers: [
      'Синтаксис для извлечения значений из массивов или свойств объектов в отдельные переменные',
      'Способ создания объектов',
      'Способ работы с функциями',
      'Альтернативное название для присваивания',
    ],
    correctAnswerIndex: 0,
    explanation: 'Деструктуризация позволяет извлекать значения из массивов или свойств объектов в отдельные переменные. Это делает код более читаемым и позволяет легко извлекать нужные значения.',
  },
  {
    id: 'js-7',
    category: 'JavaScript',
    question: 'В чем разница между == и === в JavaScript?',
    answers: [
      '== выполняет приведение типов перед сравнением, === сравнивает без приведения типов (строгое сравнение)',
      '== и === работают одинаково',
      '== работает только с числами',
      '=== работает только со строками',
    ],
    correctAnswerIndex: 0,
    explanation: '== выполняет приведение типов перед сравнением (1 == "1" вернет true), === сравнивает без приведения типов (1 === "1" вернет false). Всегда используйте === для строгого сравнения.',
  },
  {
    id: 'js-8',
    category: 'JavaScript',
    question: 'Что такое hoisting в JavaScript?',
    answers: [
      'Механизм, при котором объявления переменных и функций поднимаются в начало своей области видимости',
      'Способ создания переменных',
      'Способ работы с функциями',
      'Альтернативное название для замыкания',
    ],
    correctAnswerIndex: 0,
    explanation: 'Hoisting - это механизм JavaScript, при котором объявления переменных (var) и функций поднимаются в начало своей области видимости. Это означает, что вы можете использовать переменную или функцию до ее объявления.',
  },
  {
    id: 'js-9',
    category: 'JavaScript',
    question: 'В чем разница между bind, call и apply?',
    answers: [
      'bind возвращает новую функцию с привязанным контекстом, call и apply сразу вызывают функцию. call принимает аргументы через запятую, apply - массив',
      'bind, call и apply работают одинаково',
      'bind работает только с объектами',
      'apply работает только с массивами',
    ],
    correctAnswerIndex: 0,
    explanation: 'bind возвращает новую функцию с привязанным контекстом this. call и apply сразу вызывают функцию с указанным контекстом. call принимает аргументы через запятую, apply - массив аргументов.',
  },
  {
    id: 'js-10',
    category: 'JavaScript',
    question: 'В чем разница между Map и Object в JavaScript?',
    answers: [
      'Map может иметь ключи любого типа, хранит размер, имеет порядок обхода, не подмешивает ключи из прототипа',
      'Map и Object - это одно и то же',
      'Map работает только с примитивами',
      'Object работает только со строками',
    ],
    correctAnswerIndex: 0,
    explanation: 'Map - специализированная структура данных с преимуществами: ключи любого типа, хранит размер, натуральный порядок обхода, не подмешивает ключи из прототипа. Object имеет строковые ключи и наследует свойства прототипа.',
  },
  {
    id: 'js-11',
    category: 'JavaScript',
    question: 'Что такое прототип (prototype) в JavaScript?',
    answers: [
      'Механизм наследования, при котором объекты могут наследовать свойства и методы от других объектов',
      'Способ создания объектов',
      'Способ работы с массивами',
      'Альтернативное название для класса',
    ],
    correctAnswerIndex: 0,
    explanation: 'Прототип - это механизм наследования в JavaScript. Каждый объект имеет ссылку на прототип, от которого он наследует свойства и методы. Это основа прототипного наследования в JavaScript.',
  },
  {
    id: 'js-12',
    category: 'JavaScript',
    question: 'Что такое this в JavaScript?',
    answers: [
      'Специальное ключевое слово, которое ссылается на контекст выполнения функции',
      'Способ создания переменных',
      'Способ работы с массивами',
      'Альтернативное название для window',
    ],
    correctAnswerIndex: 0,
    explanation: 'this - это ключевое слово, которое ссылается на контекст выполнения функции. Значение this зависит от того, как функция была вызвана: как метод объекта, как обычная функция, с bind/call/apply, или как стрелочная функция.',
  },
  // HTML
  {
    id: 'html-1',
    category: 'HTML',
    question: 'Что такое семантические HTML элементы?',
    answers: [
      'Элементы, которые четко описывают свое значение и назначение как для браузера, так и для разработчика',
      'Элементы, которые работают только в современных браузерах',
      'Элементы, которые требуют JavaScript',
      'Альтернативное название для div',
    ],
    correctAnswerIndex: 0,
    explanation: 'Семантические HTML элементы (header, nav, main, article, section, footer и т.д.) четко описывают свое значение, улучшая доступность, SEO и читаемость кода.',
  },
  {
    id: 'html-2',
    category: 'HTML',
    question: 'В чем разница между <div> и <span>?',
    answers: [
      'div - блочный элемент, span - строчный элемент',
      'div и span - это одно и то же',
      'div работает только в старых браузерах',
      'span работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'div - блочный элемент, который занимает всю доступную ширину и создает новую строку. span - строчный элемент, который занимает только необходимое пространство и не создает новую строку.',
  },
  {
    id: 'html-3',
    category: 'HTML',
    question: 'Что такое DOCTYPE в HTML?',
    answers: [
      'Объявление типа документа, которое указывает браузеру, какую версию HTML использовать',
      'Способ создания элементов',
      'Способ работы с CSS',
      'Альтернативное название для html тега',
    ],
    correctAnswerIndex: 0,
    explanation: 'DOCTYPE (Document Type Declaration) - это объявление в начале HTML документа, которое указывает браузеру версию HTML и режим отображения. Современный DOCTYPE: <!DOCTYPE html>.',
  },
  {
    id: 'html-4',
    category: 'HTML',
    question: 'В чем разница между async и defer атрибутами у тега <script>?',
    answers: [
      'async загружает скрипт асинхронно и выполняет сразу после загрузки, defer загружает асинхронно, но выполняет после парсинга HTML',
      'async и defer работают одинаково',
      'async работает только в старых браузерах',
      'defer работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'async загружает скрипт асинхронно и выполняет его сразу после загрузки, не дожидаясь парсинга HTML. defer загружает асинхронно, но выполняет только после того, как HTML полностью распарсен.',
  },
  {
    id: 'html-5',
    category: 'HTML',
    question: 'Что такое data-* атрибуты в HTML?',
    answers: [
      'Специальные атрибуты для хранения пользовательских данных, доступных через JavaScript',
      'Атрибуты для работы с CSS',
      'Атрибуты для работы с сервером',
      'Альтернативное название для id',
    ],
    correctAnswerIndex: 0,
    explanation: 'data-* атрибуты позволяют хранить пользовательские данные в HTML элементах. Они доступны через dataset API в JavaScript: element.dataset.myAttribute.',
  },
  // CSS
  {
    id: 'css-1',
    category: 'CSS',
    question: 'В чем разница между display: none и visibility: hidden?',
    answers: [
      'display: none удаляет элемент из макета, visibility: hidden скрывает элемент, сохраняя его место в макете',
      'display: none и visibility: hidden работают одинаково',
      'display: none работает только в старых браузерах',
      'visibility: hidden работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'display: none полностью удаляет элемент из потока документа, элемент не занимает места. visibility: hidden скрывает элемент визуально, но он продолжает занимать место в макете.',
  },
  {
    id: 'css-2',
    category: 'CSS',
    question: 'В чем разница между em и rem?',
    answers: [
      'em вычисляется от размера шрифта родительского элемента, rem - от размера шрифта корневого элемента',
      'em и rem работают одинаково',
      'em работает только в старых браузерах',
      'rem работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'em - относительная единица, вычисляется от размера шрифта родительского элемента. rem - относительная единица, вычисляется от размера шрифта корневого элемента (html). rem более предсказуем.',
  },
  {
    id: 'css-3',
    category: 'CSS',
    question: 'В чем разница между Flexbox и Grid?',
    answers: [
      'Flexbox предназначен для одномерных макетов (строка или колонка), Grid - для двумерных макетов (строки и колонки одновременно)',
      'Flexbox и Grid работают одинаково',
      'Flexbox работает только в старых браузерах',
      'Grid работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'Flexbox идеален для одномерных макетов (выравнивание элементов в строке или колонке). Grid предназначен для двумерных макетов, где нужно управлять и строками, и колонками одновременно.',
  },
  {
    id: 'css-4',
    category: 'CSS',
    question: 'Что такое CSS специфичность (specificity)?',
    answers: [
      'Правило, определяющее приоритет селекторов: id (100), class/атрибут/псевдокласс (10), элемент/псевдоэлемент (1)',
      'Способ создания селекторов',
      'Способ работы с анимациями',
      'Альтернативное название для !important',
    ],
    correctAnswerIndex: 0,
    explanation: 'Специфичность определяет приоритет селекторов: id = 100, class/атрибут/псевдокласс = 10, элемент/псевдоэлемент = 1. Селектор с большей специфичностью имеет приоритет. !important имеет наивысший приоритет.',
  },
  {
    id: 'css-5',
    category: 'CSS',
    question: 'Что такое схлопывание внешних отступов (margin collapsing)?',
    answers: [
      'Механизм, при котором два соседних блока с внешними отступами объединяют отступы, применяя максимальный',
      'Способ создания отступов',
      'Способ работы с границами',
      'Альтернативное название для padding',
    ],
    correctAnswerIndex: 0,
    explanation: 'Margin collapsing происходит, когда два вертикальных блока имеют внешние отступы. Браузер берет максимальный отступ и применяет его к обоим блокам. Это можно избежать, используя padding, border или overflow: hidden.',
  },
  {
    id: 'css-6',
    category: 'CSS',
    question: 'В чем разница между position: relative, absolute, fixed и sticky?',
    answers: [
      'relative - относительно своего обычного положения, absolute - относительно ближайшего позиционированного родителя, fixed - относительно viewport, sticky - комбинация relative и fixed',
      'Все четыре работают одинаково',
      'relative работает только в старых браузерах',
      'sticky работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'relative - элемент остается в потоке, но можно сместить относительно обычного положения. absolute - элемент выходит из потока, позиционируется относительно ближайшего позиционированного родителя. fixed - относительно viewport. sticky - комбинация relative и fixed.',
  },
  {
    id: 'css-7',
    category: 'CSS',
    question: 'Что такое box-sizing в CSS?',
    answers: [
      'Свойство, определяющее, как вычисляется ширина и высота элемента: content-box (по умолчанию) или border-box',
      'Способ создания коробок',
      'Способ работы с отступами',
      'Альтернативное название для width',
    ],
    correctAnswerIndex: 0,
    explanation: 'box-sizing определяет модель расчета размеров: content-box (ширина/высота = только контент) или border-box (ширина/высота = контент + padding + border). border-box упрощает расчеты размеров.',
  },
  {
    id: 'css-8',
    category: 'CSS',
    question: 'В чем разница между normalize.css и reset.css?',
    answers: [
      'reset.css сбрасывает все стили к нулю, normalize.css приводит стили к согласованным значениям между браузерами',
      'normalize.css и reset.css работают одинаково',
      'reset.css работает только в старых браузерах',
      'normalize.css работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'reset.css полностью сбрасывает все стили браузера к нулю. normalize.css приводит стили к согласованным значениям между браузерами, сохраняя полезные стили по умолчанию.',
  },
  {
    id: 'css-9',
    category: 'CSS',
    question: 'Что такое BEM (Block Element Modifier)?',
    answers: [
      'Методология именования CSS классов для создания переиспользуемых компонентов',
      'Способ создания анимаций',
      'Способ работы с селекторами',
      'Альтернативное название для CSS модулей',
    ],
    correctAnswerIndex: 0,
    explanation: 'BEM - методология именования: Block__Element--Modifier. Блок - независимый компонент, Элемент - часть блока, Модификатор - вариант блока или элемента. Улучшает читаемость и поддерживаемость кода.',
  },
  {
    id: 'css-10',
    category: 'CSS',
    question: 'Что такое CSS-in-JS?',
    answers: [
      'Подход к стилизации, при котором CSS пишется внутри JavaScript кода',
      'Способ создания CSS файлов',
      'Способ работы с селекторами',
      'Альтернативное название для SCSS',
    ],
    correctAnswerIndex: 0,
    explanation: 'CSS-in-JS - подход, при котором стили пишутся в JavaScript (например, styled-components, emotion). Преимущества: динамические стили, изоляция стилей, переиспользование. Недостатки: runtime overhead, сложность отладки.',
  },
  // DOM & Events
  {
    id: 'dom-1',
    category: 'DOM & Events',
    question: 'Что такое фазы событий (event phases) в JavaScript?',
    answers: [
      'Capturing (погружение) - от корня к цели, Target - на целевом элементе, Bubbling (всплытие) - от цели к корню',
      'События имеют только одну фазу',
      'Capturing работает только в старых браузерах',
      'Bubbling работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'События проходят три фазы: Capturing (погружение от корня к целевому элементу), Target (на целевом элементе), Bubbling (всплытие от цели к корню). По умолчанию обработчики срабатывают в фазе Bubbling.',
  },
  {
    id: 'dom-2',
    category: 'DOM & Events',
    question: 'В чем разница между event.target и event.currentTarget?',
    answers: [
      'target - элемент, на котором произошло событие, currentTarget - элемент, на котором висит обработчик',
      'target и currentTarget - это одно и то же',
      'target работает только в старых браузерах',
      'currentTarget работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'event.target - элемент, на котором изначально произошло событие (не меняется). event.currentTarget - элемент, на котором в данный момент висит обработчик (меняется при всплытии).',
  },
  {
    id: 'dom-3',
    category: 'DOM & Events',
    question: 'Что такое event delegation (делегирование событий)?',
    answers: [
      'Паттерн, при котором обработчик вешается на родительский элемент для обработки событий дочерних элементов',
      'Способ создания событий',
      'Способ работы с анимациями',
      'Альтернативное название для addEventListener',
    ],
    correctAnswerIndex: 0,
    explanation: 'Event delegation - паттерн, при котором один обработчик на родительском элементе обрабатывает события всех дочерних элементов через всплытие. Преимущества: меньше обработчиков, работает с динамически добавленными элементами.',
  },
  {
    id: 'dom-4',
    category: 'DOM & Events',
    question: 'Что такое debounce и throttle?',
    answers: [
      'Debounce откладывает выполнение функции до окончания серии вызовов, throttle ограничивает частоту выполнения функции',
      'Debounce и throttle работают одинаково',
      'Debounce работает только в старых браузерах',
      'Throttle работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'Debounce откладывает выполнение функции до тех пор, пока не пройдет определенное время без новых вызовов (например, поиск при вводе). Throttle ограничивает частоту выполнения функции (например, скролл).',
  },
  // Browser & Web APIs
  {
    id: 'browser-1',
    category: 'Browser & Web APIs',
    question: 'Что такое LocalStorage и SessionStorage?',
    answers: [
      'LocalStorage хранит данные без срока действия, SessionStorage - только на время сессии браузера',
      'LocalStorage и SessionStorage работают одинаково',
      'LocalStorage работает только в старых браузерах',
      'SessionStorage работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'LocalStorage хранит данные без срока действия, данные сохраняются даже после закрытия браузера. SessionStorage хранит данные только на время сессии (до закрытия вкладки). Оба имеют ограничение ~5-10MB.',
  },
  {
    id: 'browser-2',
    category: 'Browser & Web APIs',
    question: 'Что такое CORS (Cross-Origin Resource Sharing)?',
    answers: [
      'Механизм безопасности браузера, который позволяет серверу разрешать запросы с других доменов',
      'Способ создания запросов',
      'Способ работы с cookies',
      'Альтернативное название для JSONP',
    ],
    correctAnswerIndex: 0,
    explanation: 'CORS - механизм безопасности, который позволяет серверу указать, какие домены могут делать запросы к нему. Браузер блокирует cross-origin запросы, если сервер не разрешает их через CORS заголовки.',
  },
  {
    id: 'browser-3',
    category: 'Browser & Web APIs',
    question: 'Что такое Web Workers?',
    answers: [
      'API для выполнения JavaScript кода в фоновом потоке, не блокируя основной поток',
      'Способ создания элементов',
      'Способ работы с DOM',
      'Альтернативное название для Service Workers',
    ],
    correctAnswerIndex: 0,
    explanation: 'Web Workers позволяют выполнять JavaScript код в отдельном фоновом потоке, не блокируя основной поток UI. Полезны для тяжелых вычислений, обработки данных, не затрагивая отзывчивость интерфейса.',
  },
  {
    id: 'browser-4',
    category: 'Browser & Web APIs',
    question: 'Что такое Service Worker?',
    answers: [
      'Скрипт, который работает в фоне браузера и может перехватывать сетевые запросы, кэшировать ресурсы',
      'Способ создания элементов',
      'Способ работы с DOM',
      'Альтернативное название для Web Workers',
    ],
    correctAnswerIndex: 0,
    explanation: 'Service Worker - скрипт, работающий в фоне браузера, может перехватывать сетевые запросы, кэшировать ресурсы, отправлять push-уведомления. Основа для Progressive Web Apps (PWA) и офлайн-функциональности.',
  },
  // Performance
  {
    id: 'perf-5',
    category: 'Performance',
    question: 'Что такое Critical Rendering Path?',
    answers: [
      'Последовательность шагов, которые браузер выполняет для преобразования HTML, CSS и JavaScript в отображаемую страницу',
      'Способ создания страниц',
      'Способ работы с анимациями',
      'Альтернативное название для SSR',
    ],
    correctAnswerIndex: 0,
    explanation: 'Critical Rendering Path включает: построение DOM из HTML, построение CSSOM из CSS, создание Render Tree, Layout (reflow), Painting. Оптимизация CRP улучшает время первой отрисовки (FCP) и интерактивности (TTI).',
  },
  {
    id: 'perf-6',
    category: 'Performance',
    question: 'Что такое рефлоу (reflow) и репайнт (repaint)?',
    answers: [
      'Reflow - пересчет позиций и размеров элементов, Repaint - перерисовка элементов без изменения размеров',
      'Reflow и Repaint работают одинаково',
      'Reflow работает только в старых браузерах',
      'Repaint работает только в современных браузерах',
    ],
    correctAnswerIndex: 0,
    explanation: 'Reflow (recalculation) - пересчет позиций и размеров элементов в DOM, дорогая операция. Repaint - перерисовка элементов без изменения размеров, менее дорогая. Оптимизация: минимизировать изменения, вызывающие reflow.',
  },
  {
    id: 'perf-7',
    category: 'Performance',
    question: 'Что такое Tree Shaking?',
    answers: [
      'Техника удаления неиспользуемого кода из финального бандла во время сборки',
      'Способ создания деревьев',
      'Способ работы с DOM',
      'Альтернативное название для Code Splitting',
    ],
    correctAnswerIndex: 0,
    explanation: 'Tree Shaking - статический анализ кода, который удаляет неиспользуемые экспорты из финального бандла. Работает с ES6 модулями (import/export). Уменьшает размер бандла, улучшая время загрузки.',
  },
];

